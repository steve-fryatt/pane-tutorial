<?xml version='1.0' encoding='UTF-8' standalone='no'?>

<!DOCTYPE xmlmanual SYSTEM "../panes.dtd">

<!-- Copyright 2021, Stephen Fryatt (info@stevefryatt.org.uk)
   -
   - This file is part of Pane Tutorial:
   -
   -   http://www.stevefryatt.org.uk/software/
   -
   - Licensed under the EUPL, Version 1.2 only (the "Licence");
   - You may not use this work except in compliance with the
   - Licence.
   -
   - You may obtain a copy of the Licence at:
   -
   -   http://joinup.ec.europa.eu/software/page/eupl
   -
   - Unless required by applicable law or agreed to in
   - writing, software distributed under the Licence is
   - distributed on an "AS IS" basis, WITHOUT WARRANTIES
   - OR CONDITIONS OF ANY KIND, either express or implied.
   -
   - See the Licence for the specific language governing
   - permissions and limitations under the Licence.
  -->

<manual xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="xmldoc.xsd" version="1.8.6">

<!-- Chapter 5
   -
   - The Nested Wimp
  -->

<chapter id="chap-nest-wimp">
<resources>
<images>Chapter05</images>
<downloads>Chapter05</downloads>
</resources>
<filename>the-nested-wimp.php</filename>
<uri>the-nested-wimp</uri>
<title>The Nested Wimp</title>

<summary>It isn&rsquo;t necessary to do everything with panes by hand, so let&rsquo;s see how the Wimp can help us out. </summary>

<section>
<p>Over the past few chapters, we have explored how to use pane windows to add toolboxes and toolbars to our small application. It has been a fairly manual process: setting the windows up and then keeping everything in step whenever things move on screen.</p>

<p>If we&rsquo;re willing to forego compatibility back to RISC&nbsp;OS&nbsp;2, then there is another way. The <intro>Nested Window Manager</intro> (or Nested Wimp, as we&rsquo;ll call it from now on) was introduced by Acorn back in the late 1990s, as an add-on for the RiscPC-era systems. Intended to support things like web browsers with complex framesets and embedded objects, it is included as a standard part of the OS in RISC&nbsp;OS&nbsp;4, 5 and Six.</p>

<image id="fig-nest-wimp-paint" file="nest-wimp-paint.png" title="Amongst other things, the Nested Wimp can embed tools into scroll bars"/>

<p>The Nested Wimp&rsquo;s headline feature is the ability to attach (&ldquo;nest&rdquo;) child windows into a parent, very much as we have been doing with the toolbar in our example application. There are some disadvantages: it can&rsquo;t support windows <em>outside</em> the frame of the parent window, so the side toolbox that we have previously created isn&rsquo;t an option. On the positive side, it allows an application to do other more complex things like embed toolboxes into scroll bars, as seen in <reference id="fig-nest-wimp-paint"/> &ndash; previously something which required a lot of lateral thinking by an application developer.</p>

<p>Whether to use the Nested Wimp is going to be a decision for individual developers, but for modern software &ndash; albeit software which meets certain criteria &ndash; it makes a lot of sense. Use of the new functionality can significantly simply the handling of pane windows, as well as make available design options which were previously a <em>lot</em> of work to implement. Users who are installing new software are most likely to be the same users who have upgraded their OS to at least RISC&nbsp;OS&nbsp;4.02, so the lack of support for RISC&nbsp;OS&nbsp;3 may not be a big problem.</p>
</section>


<section>
<title>Re-creating our toolbar</title>

<p>To see how the Nested Wimp works, we&rsquo;ll re-create our column-heading toolbar from <reference id="chap-col-head">the last chapter</reference> using its functionality. There will be no changes required to the templates, so we can launch straight in to the code &ndash;taking <reference id="dl-col-head-2"/> as our base.</p>

<p>The first thing that we will need to change is our application&rsquo;s <file>!Run</file> file. Since we will be using the Nested Wimp, we need to check that it is actually present on the system &ndash; which we do as seen in <reference id="list-nest-wimp-run"/>.</p>

<code id="list-nest-wimp-run" lang="obey" title="The !Run file must test for the Nested Wimp">Set PaneDemo$Dir &lt;Obey$Dir&gt;

RMEnsure WindowManager 3.80 Error PaneDemo requires the Nested Window Manager.

WimpSlot -min 96K -max 96K
Run &lt;PaneDemo$Dir&gt;.!RunImage</code>

<p>Since the Window Manager can&rsquo;t be replaced whilst the system is running, all that we can do is test for it and refuse to run if it isn&rsquo;t present. The user will need to install an update in <cite>!Boot</cite> &ndash; although as already noted, a suitable version of the Window Manager is present in ROM with RISC&nbsp;OS&nbsp;4, 5 and Six.</p>

<p>We will also need to update our call to <swi>Wimp_Initialise</swi> in <function>PROCinitialise</function>. Instead of passing 310 in <name>R0</name> to indicate that we wish to use the features of RISC&nbsp;OS&nbsp;3.1, we must now pass 380 as shown in <reference id="list-nest-wimp-init"/>, to tell the Wimp that we want its nested functionality to be available to us.</p>

<code id="list-nest-wimp-init" lang="bbcbasic" title="Initialising for the Nested Wimp">q%!0 = 0 : REM Message_Quit

SYS &quot;Wimp_Initialise&quot;, 380, &amp;4B534154, TaskName$, q%</code>

<p>The big change between the two examples will be in how the toolbar pane is handled. Up to now, we have had to position our panes when the main window is initially opened, and then on every single <name>Open_Window_Request</name> event after that; we also need to remember to close them on the <name>Close_Window_Request</name> event. With the Nested Wimp we still need to position our panes when the window is initially opened, but when we do, we also let the Wimp know that they are attached to the main window &ndash; and more crucially, <em>how</em> they are attached.</p>

<p>After that, with the main window and its toolbar open on screen, the Wimp deals with all of the positioning work that we have so far done by hand. This means that we can delete <function>PROCopen_window_request()</function> and <function>PROCclose_window_request()</function>, because we no longer need to do any special work on <name>Open_Window_Request</name> or <name>Close_Window_Request</name> events, and can instead just pass them to the <swi>Wimp_OpenWindow</swi> and <swi>Wimp_CloseWindow</swi> SWIs respectively. As a result, <function>PROCpoll</function> can return to how it was in <reference id="chap-example-app"/>, as seen in <reference id="list-nest-wimp-poll"/>.</p>

<code id="list-nest-wimp-poll" lang="bbcbasic" title="Our Wimp_Poll loop has become simpler again">DEF PROCpoll
LOCAL reason%

SYS &quot;Wimp_Poll&quot;, &amp;3C01, b% TO reason%

CASE reason% OF
	WHEN 2		: SYS &quot;Wimp_OpenWindow&quot;,,b%
	WHEN 3		: SYS &quot;Wimp_CloseWindow&quot;,,b%
	WHEN 6		: PROCmouse_click(b%)
	WHEN 9		: PROCmenu_selection(b%)
	WHEN 17, 18	: IF b%!16 = 0 THEN Quit% = TRUE
ENDCASE
ENDPROC</code>

<p>Opening the main window and its pane in <function>PROCopen_main_window</function> follows a familiar pattern. We start by setting up a couple of variables, <variable>main%</variable> and <variable>toolbar%</variable>, to point to blocks of memory in which to store window state blocks for the two windows; as before, we&rsquo;re putting them both into the 256 byte buffer pointed to by <variable>q%</variable>.</p>

<code lang="bbcbasic">main% = q%
toolbar% = q% + 64</code>

<p>We then use <swi>Wimp_GetWindowState</swi> to request details of the main window, reposition it as required, and then call <swi>Wimp_OpenWindow</swi> to open it up on the desktop. This code is almost exactly the same as that used in <function>PROCopen_main_window</function>, aside from a small change to the call to <swi>Wimp_OpenWindow</swi> for the main window, which we&rsquo;ll come back to shortly.</p>

<code lang="bbcbasic">REM Get the main window details.

!main% = MainWindow%
SYS &quot;Wimp_GetWindowState&quot;,,main%

REM If the window isn't open, resize and centre it on the screen.

IF (main%!32 AND &amp;10000) = 0 THEN
  window_width% = WindowWidth%
  window_height% = WindowHeight%

  REM Read the screen dimensions.

  screen_width% = FNread_mode_dimension(11, 4)
  screen_height% = FNread_mode_dimension(12, 5)

  REM Ensure that the window fills no more than 75% of either dimension.

  IF window_width% &gt; (screen_width% * 0.75) THEN window_width% = screen_width% * 0.75
  IF window_height% &gt; (screen_height% * 0.75) THEN window_height% = screen_height% * 0.75

  REM Update the window dimensions.

  main%!4 = (screen_width% - window_width%) / 2   : REM Visible Area X0
  main%!8 = (screen_height% - window_height%) / 2 : REM Visible Area Y0

  main%!12 = main%!4 + window_width%              : REM Visible Area X1
  main%!16 = main%!8 + window_height%             : REM Visible Area Y1

  REM Reset the scroll offsets.

  main%!20 = 0                                    : REM X Scroll Offset
  main%!24 = 0                                    : REM Y Scroll Offset
ENDIF

REM Open the window at the top of the window stack.

main%!28 = -1 : REM Window to open behind (-1 is top of stack)

SYS &quot;Wimp_OpenWindow&quot;,,main%, &amp;4B534154, -1, &amp;0</code>

<p>Previously, at this point, we would call <function>PROChandle_pane_windows()</function> to set up and open the toolbar pane. Since positioning the windows is a one-off operation with the Nested Wimp, however, we will bring the code into <function>PROCopen_main_window</function>. Most of the code is identical to that which we have used before: getting the toolbar pane&rsquo;s details with <swi>Wimp_GetWindowState</swi>, then adjusting the position to suit the location of the main window.</p>

<code lang="bbcbasic">REM Get the toolbar details

!toolbar% = ToolBarWindow%
SYS &quot;Wimp_GetWindowState&quot;,,toolbar%

REM Find the height of the toolbar pane's visible area.

bar_height% = toolbar%!16 - toolbar%!8            : REM Visible Area Y1 - Y0

REM Move the toolbar pane so that it's in the correct X and Y position
REM relative to where the main window is to go.

toolbar%!4 = main%!4                              : REM Visible Area X0
toolbar%!8 = main%!16 - bar_height%               : REM Visible Area Y0
toolbar%!12 = main%!12                            : REM Visible Area X1
toolbar%!16 = main%!16                            : REM Visible Area Y1

REM Align the toolbar pane's scroll offset with the main window.

toolbar%!20 = main%!20                            : REM X Scroll Offset

REM Open the toolbox pane at the top of the stack, nested into the main window.

toolbar%!28 = -1</code>

<p>The magic of the Nested Wimp comes in the last line of the procedure, however: the call to <swi>Wimp_OpenWindow</swi> which opens the toolbar pane.</p>

<code lang="bbcbasic">SYS &quot;Wimp_OpenWindow&quot;,,toolbar%, &amp;4B534154, !main%, &amp;08A90000</code>

<p>This is the so-called &ldquo;extended syntax&rdquo; of the SWI; it still takes a pointer to the window state block in <name>R1</name>, but now <name>R2</name> contains the familiar Wimp magic constant of &amp;4B534154 &ndash; or &lsquo;TASK&rsquo; in ASCII. if present, this unlocks more functionality: <name>R3</name> now takes the handle of this window&rsquo;s <intro>parent window</intro>, while <name>R4</name> takes the <intro>nesting flags</intro>.</p>

<p>When we called <swi>Wimp_OpenWindow</swi> for the main window, we passed a parent window handle of &minus;1 to indicate that it was a <intro>top level window</intro> &ndash; that it was not to be treated as being nested within any other window. Before the advent of the Nested Wimp, all windows behaved as if they were top level windows. None of the nesting flags applied, and so they were left unset (set to &amp;0).</p>

<p>For the toolbar pane, however, we want the Wimp to treat it as being nested within the main window. To achieve this, when calling <swi>Wimp_OpenWindow</swi> for the toolbar pane, we pass the handle of the main window (the toolbar&rsquo;s parent window) in <name>R3</name>. We will also need to let the Wimp know how the two windows are joined together, and the nesting flags in <name>R4</name> do that.</p>

<!-- Nesting Flags -->



<p>Putting it all together, we can delete <function>PROChandle_pane_windows()</function>; all of the functionality is now in the new <function>PROCopen_main_window</function>, in <reference id="list-nest-wimp-open"/>.</p>

<code id="list-nest-wimp-open" lang="bbcbasic" title="Opening the nested windows">DEF PROCopen_main_window
LOCAL screen_width%, screen_height%, window_width%, window_height%, main%, toolbar%, bar_height%

REM Set up the memory blocks.

main% = q%
toolbar% = q% + 64

REM Get the main window details.

!main% = MainWindow%
SYS &quot;Wimp_GetWindowState&quot;,,main%

REM If the window isn't open, resize and centre it on the screen.

IF (main%!32 AND &amp;10000) = 0 THEN
  window_width% = WindowWidth%
  window_height% = WindowHeight%

  REM Read the screen dimensions.

  screen_width% = FNread_mode_dimension(11, 4)
  screen_height% = FNread_mode_dimension(12, 5)

  REM Ensure that the window fills no more than 75% of either dimension.

  IF window_width% &gt; (screen_width% * 0.75) THEN window_width% = screen_width% * 0.75
  IF window_height% &gt; (screen_height% * 0.75) THEN window_height% = screen_height% * 0.75

  REM Update the window dimensions.

  main%!4 = (screen_width% - window_width%) / 2   : REM Visible Area X0
  main%!8 = (screen_height% - window_height%) / 2 : REM Visible Area Y0

  main%!12 = main%!4 + window_width%              : REM Visible Area X1
  main%!16 = main%!8 + window_height%             : REM Visible Area Y1

  REM Reset the scroll offsets.

  main%!20 = 0                                    : REM X Scroll Offset
  main%!24 = 0                                    : REM Y Scroll Offset
ENDIF

REM Open the window at the top of the window stack.

main%!28 = -1 : REM Window to open behind (-1 is top of stack)

SYS &quot;Wimp_OpenWindow&quot;,,main%, &amp;4B534154, -1, &amp;0

REM Get the toolbar details

!toolbar% = ToolBarWindow%
SYS &quot;Wimp_GetWindowState&quot;,,toolbar%

REM Find the height of the toolbar pane's visible area.

bar_height% = toolbar%!16 - toolbar%!8            : REM Visible Area Y1 - Y0

REM Move the toolbar pane so that it's in the correct X and Y position
REM relative to where the main window is to go.

toolbar%!4 = main%!4                              : REM Visible Area X0
toolbar%!8 = main%!16 - bar_height%               : REM Visible Area Y0
toolbar%!12 = main%!12                            : REM Visible Area X1
toolbar%!16 = main%!16                            : REM Visible Area Y1

REM Align the toolbar pane's scroll offset with the main window.

toolbar%!20 = main%!20                            : REM X Scroll Offset

REM Open the toolbox pane at the top of the stack, nested into the main window.

toolbar%!28 = -1

SYS &quot;Wimp_OpenWindow&quot;,,toolbar%, &amp;4B534154, !main%, &amp;08A90000
ENDPROC</code>






</section>
</chapter>
</manual>

